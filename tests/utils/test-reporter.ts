import { Reporter, TestCase, TestResult, FullResult, Suite } from '@playwright/test/reporter';
import fs from 'fs';
import path from 'path';

/**
 * Professional Markdown Test Reporter for [RE]Print Studios
 */
export class MarkdownReporter implements Reporter {
  private results: Map<string, TestResult[]> = new Map();
  private startTime: Date;
  private totalTests = 0;
  private passedTests = 0;
  private failedTests = 0;
  private skippedTests = 0;
  private flakyTests = 0;
  private suiteResults: Map<string, SuiteResult> = new Map();

  onBegin(config: any, suite: Suite) {
    this.startTime = new Date();
    this.totalTests = suite.allTests().length;
    console.log(`üß™ Starting test run with ${this.totalTests} tests...`);
  }

  onTestEnd(test: TestCase, result: TestResult) {
    const suiteName = test.parent.title;
    
    if (!this.results.has(suiteName)) {
      this.results.set(suiteName, []);
    }
    
    this.results.get(suiteName)!.push(result);
    
    // Update counters
    switch (result.status) {
      case 'passed':
        this.passedTests++;
        break;
      case 'failed':
        this.failedTests++;
        break;
      case 'skipped':
        this.skippedTests++;
        break;
      case 'flaky':
        this.flakyTests++;
        break;
    }

    // Update suite results
    if (!this.suiteResults.has(suiteName)) {
      this.suiteResults.set(suiteName, {
        name: suiteName,
        passed: 0,
        failed: 0,
        skipped: 0,
        flaky: 0,
        duration: 0,
        tests: []
      });
    }

    const suite = this.suiteResults.get(suiteName)!;
    suite.tests.push({ test, result });
    suite.duration += result.duration;
    
    switch (result.status) {
      case 'passed':
        suite.passed++;
        break;
      case 'failed':
        suite.failed++;
        break;
      case 'skipped':
        suite.skipped++;
        break;
      case 'flaky':
        suite.flaky++;
        break;
    }
  }

  async onEnd(result: FullResult) {
    const endTime = new Date();
    const duration = (endTime.getTime() - this.startTime.getTime()) / 1000;
    
    // Generate comprehensive report
    const report = this.generateMarkdownReport(duration, result.status);
    
    // Write report to file
    const reportPath = path.join(process.cwd(), 'test-results', 'test-report.md');
    fs.mkdirSync(path.dirname(reportPath), { recursive: true });
    fs.writeFileSync(reportPath, report);
    
    // Also generate a summary report
    const summaryReport = this.generateSummaryReport(duration, result.status);
    const summaryPath = path.join(process.cwd(), 'test-results', 'test-summary.md');
    fs.writeFileSync(summaryPath, summaryReport);
    
    console.log(`\nüìÑ Test reports generated:`);
    console.log(`   - Full report: ${reportPath}`);
    console.log(`   - Summary: ${summaryPath}`);
    console.log(`\n‚ú® ${this.passedTests}/${this.totalTests} tests passed (${Math.round((this.passedTests/this.totalTests)*100)}%)`);
  }

  private generateMarkdownReport(duration: number, status: string): string {
    const report = [];
    
    // Header
    report.push('# [RE]Print Studios - Comprehensive E2E Test Report');
    report.push(`\n> Generated on ${new Date().toLocaleString()}`);
    report.push(`> Total Duration: ${this.formatDuration(duration)}`);
    report.push(`> Status: ${this.getStatusBadge(status)}\n`);
    
    // Executive Summary
    report.push('## üìä Executive Summary\n');
    report.push(this.generateExecutiveSummary());
    
    // Test Statistics
    report.push('\n## üìà Test Statistics\n');
    report.push(this.generateStatisticsTable());
    
    // Coverage Overview
    report.push('\n## üéØ Coverage Overview\n');
    report.push(this.generateCoverageOverview());
    
    // Suite Results
    report.push('\n## üß™ Test Suite Results\n');
    
    // Sort suites by importance
    const sortedSuites = this.sortSuitesByPriority();
    
    for (const [suiteName, suite] of sortedSuites) {
      report.push(this.generateSuiteSection(suiteName, suite));
    }
    
    // Failed Tests Details
    if (this.failedTests > 0) {
      report.push('\n## ‚ùå Failed Tests Details\n');
      report.push(this.generateFailedTestsSection());
    }
    
    // Performance Metrics
    report.push('\n## ‚ö° Performance Metrics\n');
    report.push(this.generatePerformanceSection());
    
    // Browser Coverage
    report.push('\n## üåê Browser Coverage\n');
    report.push(this.generateBrowserCoverage());
    
    // Recommendations
    report.push('\n## üí° Recommendations\n');
    report.push(this.generateRecommendations());
    
    // Footer
    report.push('\n---\n');
    report.push('*This report was automatically generated by the [RE]Print Studios Test Suite*');
    
    return report.join('\n');
  }

  private generateExecutiveSummary(): string {
    const passRate = Math.round((this.passedTests / this.totalTests) * 100);
    const summary = [];
    
    if (passRate === 100) {
      summary.push('### ‚úÖ All Tests Passed!');
      summary.push('\nThe [RE]Print Studios application has successfully passed all E2E tests, demonstrating:');
      summary.push('- **100% functionality** across all tested features');
      summary.push('- **Robust error handling** and edge case coverage');
      summary.push('- **Cross-browser compatibility** verified');
      summary.push('- **Security measures** properly implemented');
    } else if (passRate >= 90) {
      summary.push('### ‚ö†Ô∏è High Pass Rate with Minor Issues');
      summary.push(`\n${passRate}% of tests passed, indicating strong overall functionality with some areas needing attention.`);
    } else {
      summary.push('### ‚ùå Critical Issues Detected');
      summary.push(`\nOnly ${passRate}% of tests passed. Immediate attention required for failing components.`);
    }
    
    // Key metrics
    summary.push('\n#### Key Metrics:');
    summary.push(`- **Total Tests**: ${this.totalTests}`);
    summary.push(`- **Pass Rate**: ${passRate}%`);
    summary.push(`- **Execution Time**: ${this.formatDuration((new Date().getTime() - this.startTime.getTime()) / 1000)}`);
    summary.push(`- **Test Suites**: ${this.suiteResults.size}`);
    
    return summary.join('\n');
  }

  private generateStatisticsTable(): string {
    const table = [];
    table.push('| Metric | Count | Percentage |');
    table.push('|--------|-------|------------|');
    table.push(`| ‚úÖ Passed | ${this.passedTests} | ${this.getPercentage(this.passedTests)}% |`);
    table.push(`| ‚ùå Failed | ${this.failedTests} | ${this.getPercentage(this.failedTests)}% |`);
    table.push(`| ‚è≠Ô∏è Skipped | ${this.skippedTests} | ${this.getPercentage(this.skippedTests)}% |`);
    table.push(`| üîÑ Flaky | ${this.flakyTests} | ${this.getPercentage(this.flakyTests)}% |`);
    table.push(`| **Total** | **${this.totalTests}** | **100%** |`);
    
    return table.join('\n');
  }

  private generateCoverageOverview(): string {
    const coverage = [];
    
    coverage.push('### Feature Coverage\n');
    coverage.push('| Feature Area | Status | Tests | Notes |');
    coverage.push('|--------------|--------|-------|-------|');
    
    // Analyze coverage by suite names
    const coverageAreas = this.analyzeCoverage();
    
    for (const area of coverageAreas) {
      coverage.push(`| ${area.name} | ${area.status} | ${area.testCount} | ${area.notes} |`);
    }
    
    return coverage.join('\n');
  }

  private generateSuiteSection(suiteName: string, suite: SuiteResult): string {
    const section = [];
    const passRate = suite.passed / suite.tests.length * 100;
    
    section.push(`### ${this.getSuiteIcon(suiteName)} ${suiteName}`);
    section.push(`\n> Pass Rate: ${passRate.toFixed(1)}% | Duration: ${this.formatDuration(suite.duration / 1000)}`);
    
    if (suite.tests.length > 0) {
      section.push('\n| Test | Status | Duration | Browser |');
      section.push('|------|--------|----------|---------|');
      
      for (const { test, result } of suite.tests) {
        const testName = test.title.length > 50 ? test.title.substring(0, 47) + '...' : test.title;
        const browser = test.parent.project()?.name || 'unknown';
        section.push(`| ${testName} | ${this.getStatusIcon(result.status)} | ${result.duration}ms | ${browser} |`);
      }
    }
    
    section.push('');
    return section.join('\n');
  }

  private generateFailedTestsSection(): string {
    const failed = [];
    
    for (const [suiteName, suite] of this.suiteResults) {
      const failedTests = suite.tests.filter(t => t.result.status === 'failed');
      
      if (failedTests.length > 0) {
        failed.push(`### ${suiteName}\n`);
        
        for (const { test, result } of failedTests) {
          failed.push(`#### ‚ùå ${test.title}`);
          failed.push('```');
          failed.push(result.error?.message || 'Unknown error');
          failed.push('```');
          
          if (result.error?.stack) {
            failed.push('\n<details>');
            failed.push('<summary>Stack Trace</summary>\n');
            failed.push('```');
            failed.push(result.error.stack);
            failed.push('```');
            failed.push('</details>\n');
          }
          
          // Add screenshot/video links if available
          if (result.attachments?.length > 0) {
            failed.push('**Attachments:**');
            for (const attachment of result.attachments) {
              if (attachment.name === 'screenshot') {
                failed.push(`- [Screenshot](${attachment.path})`);
              } else if (attachment.name === 'video') {
                failed.push(`- [Video](${attachment.path})`);
              }
            }
            failed.push('');
          }
        }
      }
    }
    
    return failed.join('\n');
  }

  private generatePerformanceSection(): string {
    const perf = [];
    
    // Find slowest tests
    const allTests: Array<{name: string, duration: number, suite: string}> = [];
    
    for (const [suiteName, suite] of this.suiteResults) {
      for (const { test, result } of suite.tests) {
        allTests.push({
          name: test.title,
          duration: result.duration,
          suite: suiteName
        });
      }
    }
    
    allTests.sort((a, b) => b.duration - a.duration);
    
    perf.push('### ‚è±Ô∏è Slowest Tests\n');
    perf.push('| Test | Suite | Duration |');
    perf.push('|------|-------|----------|');
    
    for (const test of allTests.slice(0, 10)) {
      perf.push(`| ${test.name.substring(0, 40)}... | ${test.suite} | ${test.duration}ms |`);
    }
    
    // Average duration by suite
    perf.push('\n### üìä Average Duration by Suite\n');
    perf.push('| Suite | Avg Duration | Total Duration |');
    perf.push('|-------|--------------|----------------|');
    
    for (const [suiteName, suite] of this.suiteResults) {
      const avgDuration = suite.duration / suite.tests.length / 1000;
      perf.push(`| ${suiteName} | ${avgDuration.toFixed(2)}s | ${(suite.duration / 1000).toFixed(2)}s |`);
    }
    
    return perf.join('\n');
  }

  private generateBrowserCoverage(): string {
    const browsers = new Map<string, { passed: number, failed: number, total: number }>();
    
    // Collect browser statistics
    for (const [_, suite] of this.suiteResults) {
      for (const { test, result } of suite.tests) {
        const browser = test.parent.project()?.name || 'unknown';
        
        if (!browsers.has(browser)) {
          browsers.set(browser, { passed: 0, failed: 0, total: 0 });
        }
        
        const stats = browsers.get(browser)!;
        stats.total++;
        
        if (result.status === 'passed') {
          stats.passed++;
        } else if (result.status === 'failed') {
          stats.failed++;
        }
      }
    }
    
    const coverage = [];
    coverage.push('| Browser | Tests Run | Passed | Failed | Pass Rate |');
    coverage.push('|---------|-----------|--------|--------|-----------|');
    
    for (const [browser, stats] of browsers) {
      const passRate = (stats.passed / stats.total * 100).toFixed(1);
      coverage.push(`| ${browser} | ${stats.total} | ${stats.passed} | ${stats.failed} | ${passRate}% |`);
    }
    
    return coverage.join('\n');
  }

  private generateRecommendations(): string {
    const recs = [];
    
    if (this.failedTests > 0) {
      recs.push('### üîß Immediate Actions Required:\n');
      recs.push('1. **Fix failing tests** - Review error logs and stack traces above');
      recs.push('2. **Check test environment** - Ensure all services are running correctly');
      recs.push('3. **Verify test data** - Confirm database is in expected state');
    }
    
    if (this.flakyTests > 0) {
      recs.push('\n### üîÑ Flaky Test Improvements:\n');
      recs.push('1. **Add retry logic** - Implement smart retries for network operations');
      recs.push('2. **Increase timeouts** - Some operations may need longer wait times');
      recs.push('3. **Improve selectors** - Use more specific, stable selectors');
    }
    
    // Performance recommendations
    const slowTests = this.findSlowTests();
    if (slowTests.length > 0) {
      recs.push('\n### ‚ö° Performance Optimizations:\n');
      recs.push('1. **Optimize slow tests** - Tests taking >10s should be reviewed');
      recs.push('2. **Parallelize test execution** - Run independent tests concurrently');
      recs.push('3. **Reduce test data setup** - Use minimal required data');
    }
    
    // General best practices
    recs.push('\n### üìö Best Practices:\n');
    recs.push('- **Regular test maintenance** - Review and update tests with feature changes');
    recs.push('- **Monitor test trends** - Track pass rates and execution times over time');
    recs.push('- **Expand coverage** - Add tests for new features and edge cases');
    
    return recs.join('\n');
  }

  private generateSummaryReport(duration: number, status: string): string {
    const summary = [];
    
    summary.push('# [RE]Print Studios - Test Summary\n');
    summary.push(`**Date**: ${new Date().toLocaleString()}`);
    summary.push(`**Duration**: ${this.formatDuration(duration)}`);
    summary.push(`**Status**: ${this.getStatusBadge(status)}\n`);
    
    summary.push('## Quick Stats\n');
    summary.push(`- ‚úÖ **Passed**: ${this.passedTests}`);
    summary.push(`- ‚ùå **Failed**: ${this.failedTests}`);
    summary.push(`- ‚è≠Ô∏è **Skipped**: ${this.skippedTests}`);
    summary.push(`- üìä **Total**: ${this.totalTests}`);
    summary.push(`- üéØ **Pass Rate**: ${Math.round((this.passedTests/this.totalTests)*100)}%\n`);
    
    if (this.failedTests > 0) {
      summary.push('## Failed Tests\n');
      for (const [suiteName, suite] of this.suiteResults) {
        const failed = suite.tests.filter(t => t.result.status === 'failed');
        if (failed.length > 0) {
          summary.push(`### ${suiteName}`);
          for (const { test } of failed) {
            summary.push(`- ‚ùå ${test.title}`);
          }
          summary.push('');
        }
      }
    }
    
    return summary.join('\n');
  }

  // Helper methods
  private formatDuration(seconds: number): string {
    if (seconds < 60) {
      return `${seconds.toFixed(1)}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
  }

  private getStatusBadge(status: string): string {
    switch (status) {
      case 'passed':
        return '‚úÖ **PASSED**';
      case 'failed':
        return '‚ùå **FAILED**';
      case 'timedout':
        return '‚è±Ô∏è **TIMEOUT**';
      case 'interrupted':
        return 'üõë **INTERRUPTED**';
      default:
        return `üìä **${status.toUpperCase()}**`;
    }
  }

  private getStatusIcon(status: string): string {
    switch (status) {
      case 'passed':
        return '‚úÖ';
      case 'failed':
        return '‚ùå';
      case 'skipped':
        return '‚è≠Ô∏è';
      case 'flaky':
        return 'üîÑ';
      default:
        return '‚ùì';
    }
  }

  private getSuiteIcon(suiteName: string): string {
    if (suiteName.includes('Auth')) return 'üîê';
    if (suiteName.includes('Phase')) return 'üìä';
    if (suiteName.includes('File')) return 'üìÅ';
    if (suiteName.includes('Payment')) return 'üí≥';
    if (suiteName.includes('Admin')) return 'üë®‚Äçüíº';
    if (suiteName.includes('Client')) return 'üë§';
    if (suiteName.includes('Security')) return 'üõ°Ô∏è';
    if (suiteName.includes('Performance')) return '‚ö°';
    if (suiteName.includes('Accessibility')) return '‚ôø';
    return 'üß™';
  }

  private getPercentage(count: number): number {
    return Math.round((count / this.totalTests) * 100);
  }

  private sortSuitesByPriority(): Array<[string, SuiteResult]> {
    const priority = [
      'Authentication',
      'Phase Management',
      'Client Portal',
      'Admin Portal',
      'Payment',
      'Security'
    ];
    
    return Array.from(this.suiteResults.entries()).sort((a, b) => {
      const aPriority = priority.findIndex(p => a[0].includes(p));
      const bPriority = priority.findIndex(p => b[0].includes(p));
      
      if (aPriority === -1 && bPriority === -1) return 0;
      if (aPriority === -1) return 1;
      if (bPriority === -1) return -1;
      
      return aPriority - bPriority;
    });
  }

  private analyzeCoverage(): Array<{name: string, status: string, testCount: number, notes: string}> {
    return [
      {
        name: 'üîê Authentication',
        status: this.getCoverageStatus('Auth'),
        testCount: this.getTestCount('Auth'),
        notes: 'Login, logout, session management'
      },
      {
        name: 'üìä Phase System',
        status: this.getCoverageStatus('Phase'),
        testCount: this.getTestCount('Phase'),
        notes: '8-phase workflow, transitions, approvals'
      },
      {
        name: 'üìÅ File Management',
        status: this.getCoverageStatus('File'),
        testCount: this.getTestCount('File'),
        notes: 'Upload, download, permissions'
      },
      {
        name: 'üí≥ Payments',
        status: this.getCoverageStatus('Payment'),
        testCount: this.getTestCount('Payment'),
        notes: 'Stripe integration, invoicing'
      },
      {
        name: 'üë®‚Äçüíº Admin Portal',
        status: this.getCoverageStatus('Admin'),
        testCount: this.getTestCount('Admin'),
        notes: 'All admin modules and functions'
      },
      {
        name: 'üí¨ Messaging',
        status: this.getCoverageStatus('Message'),
        testCount: this.getTestCount('Message'),
        notes: 'Real-time chat, notifications'
      },
      {
        name: 'üõ°Ô∏è Security',
        status: this.getCoverageStatus('Security'),
        testCount: this.getTestCount('Security'),
        notes: 'XSS, CSRF, authorization'
      },
      {
        name: '‚ôø Accessibility',
        status: this.getCoverageStatus('Accessibility'),
        testCount: this.getTestCount('Accessibility'),
        notes: 'WCAG compliance, keyboard nav'
      }
    ];
  }

  private getCoverageStatus(keyword: string): string {
    let passed = 0;
    let total = 0;
    
    for (const [suiteName, suite] of this.suiteResults) {
      if (suiteName.includes(keyword)) {
        total += suite.tests.length;
        passed += suite.passed;
      }
    }
    
    if (total === 0) return '‚ö†Ô∏è Not Tested';
    const passRate = passed / total;
    
    if (passRate === 1) return '‚úÖ Full Coverage';
    if (passRate >= 0.8) return 'üü° Good Coverage';
    return '‚ùå Needs Work';
  }

  private getTestCount(keyword: string): number {
    let count = 0;
    for (const [suiteName, suite] of this.suiteResults) {
      if (suiteName.includes(keyword)) {
        count += suite.tests.length;
      }
    }
    return count;
  }

  private findSlowTests(): Array<{name: string, duration: number}> {
    const slowTests: Array<{name: string, duration: number}> = [];
    
    for (const [_, suite] of this.suiteResults) {
      for (const { test, result } of suite.tests) {
        if (result.duration > 10000) { // Tests taking more than 10 seconds
          slowTests.push({
            name: test.title,
            duration: result.duration
          });
        }
      }
    }
    
    return slowTests.sort((a, b) => b.duration - a.duration);
  }
}

// Type definitions
interface SuiteResult {
  name: string;
  passed: number;
  failed: number;
  skipped: number;
  flaky: number;
  duration: number;
  tests: Array<{
    test: TestCase;
    result: TestResult;
  }>;
}

// Export the reporter class as default
export default MarkdownReporter;